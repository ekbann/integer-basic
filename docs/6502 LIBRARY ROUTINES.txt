======================================================================
Number output in 6502 machine code

Print 8-bit hexadecimal

Print value in A in hexadecimal padded with zeros.

   \ On entry, A=value to print
   \ On exit,  A corrupted
   
   .PrHex
   PHA                        :\ Save A
   LSR A:LSR A:LSR A:LSR A    :\ Move top nybble to bottom nybble
   JSR PrNybble               :\ Print this nybble
   PLA                        :\ Get A back and print bottom nybble
   .PrNybble
   AND #15                    :\ Keep bottom four bits
   CMP #10:BCC PrDigit        :\ If 0-9, jump to print
   ADC #6                     :\ Convert ':' to 'A'
   .PrDigit
   ADC #ASC"0":JMP OSWRCH     :\ Convert to character and print

Print 8-bit decimal

Print value in A in decimal padded with zeros.

   \ On entry, A=value to print
   \ On exit,  A corrupted
   
   .PrDec
   LDX #&FF:SEC               :\ Prepare for subtraction
   .PrDec100
   INX:SBC #100:BCS PrDec100  :\ Count how many 100s
   ADC #100:JSR PrDecDigit    :\ Print the 100s
   LDX #&FF:SEC               :\ Prepare for subtraction
   .PrDec10
   INX:SBC #10:BCS PrDec10    :\ Count how many 10s
   ADC #10:JSR PrDecDigit     :\ Print the 10s
   TAX                        :\ Pass 1s into X
   .PrDecDigit
   PHA:TXA                    :\ Save A, pass digit to A
   ORA #ASC"0":JSR OSWRCH     :\ Convert to character and print it
   PLA:RTS                    :\ Restore A and return

Print multi-byte numbers in decimal

These routines will print 16-bit, 24-bit and 32-bit values in decimal with no padding or specified character padding. They can be optimised for for specific implementations.

16-bit decimal

   \ ---------------------------
   \ Print 16-bit decimal number
   \ ---------------------------
   \ On entry, num=number to print
   \           pad=0 or pad character (eg '0' or ' ')
   \ On entry at PrDec16Lp1,
   \           Y=(number of digits)*2-2, eg 8 for 5 digits
   \ On exit,  A,X,Y,num,pad corrupted
   \ Size      69 bytes
   \ -----------------------------------------------------------------
   .PrDec16
   LDY #8                                   :\ Offset to powers of ten
   .PrDec16Lp1
   LDX #&FF:SEC                             :\ Start with digit=-1
   .PrDec16Lp2
   LDA num+0:SBC PrDec16Tens+0,Y:STA num+0  :\ Subtract current tens
   LDA num+1:SBC PrDec16Tens+1,Y:STA num+1
   INX:BCS PrDec16Lp2                       :\ Loop until <0
   LDA num+0:ADC PrDec16Tens+0,Y:STA num+0  :\ Add current tens back in
   LDA num+1:ADC PrDec16Tens+1,Y:STA num+1
   TXA:BNE PrDec16Digit                     :\ Not zero, print it
   LDA pad:BNE PrDec16Print:BEQ PrDec16Next :\ pad<>0, use it
   .PrDec16Digit
   LDX #ASC"0":STX pad                      :\ No more zero padding
   ORA #ASC"0"                              :\ Print this digit
   .PrDec16Print
   JSR OSWRCH
   .PrDec16Next
   DEY:DEY:BPL PrDec16Lp1                   :\ Loop for next digit
   RTS
   :
   .PrDec16Tens
   EQUW 1
   EQUW 10
   EQUW 100
   EQUW 1000
   EQUW 10000
   \ -----------------------------------------------------------------

32-bit decimal

   \ ---------------------------
   \ Print 32-bit decimal number
   \ ---------------------------
   \ On entry, num=number to print
   \           pad=0 or pad character (eg '0' or ' ')
   \ On entry at PrDec32Lp1,
   \           Y=(number of digits)*4-4, eg 36 for 10 digits
   \ On exit,  A,X,Y,num,pad corrupted
   \ Size      129 bytes
   \ -----------------------------------------------------------------
   .PrDec32
   LDY #36                                  :\ Offset to powers of ten
   .PrDec32Lp1
   LDX #&FF:SEC                             :\ Start with digit=-1
   .PrDec32Lp2
   LDA num+0:SBC PrDec32Tens+0,Y:STA num+0  :\ Subtract current tens
   LDA num+1:SBC PrDec32Tens+1,Y:STA num+1
   LDA num+2:SBC PrDec32Tens+2,Y:STA num+2
   LDA num+3:SBC PrDec32Tens+3,Y:STA num+3
   INX:BCS PrDec32Lp2                       :\ Loop until <0
   LDA num+0:ADC PrDec32Tens+0,Y:STA num+0  :\ Add current tens back in
   LDA num+1:ADC PrDec32Tens+1,Y:STA num+1
   LDA num+2:ADC PrDec32Tens+2,Y:STA num+2
   LDA num+3:ADC PrDec32Tens+3,Y:STA num+3
   TXA:BNE PrDec32Digit                     :\ Not zero, print it
   LDA pad:BNE PrDec32Print:BEQ PrDec32Next :\ pad<>0, use it
   .PrDec32Digit
   LDX #ASC"0":STX pad                      :\ No more zero padding
   ORA #ASC"0"                              :\ Print this digit
   .PrDec32Print
   JSR OSWRCH
   .PrDec32Next
   DEY:DEY:DEY:DEY:BPL PrDec32Lp1           :\ Loop for next digit
   RTS
   :
   .PrDec32Tens
   EQUD 1
   EQUD 10
   EQUD 100
   EQUD 1000
   EQUD 10000
   EQUD 100000
   EQUD 1000000
   EQUD 10000000
   EQUD 100000000
   EQUD 1000000000
   \ -----------------------------------------------------------------
======================================================================
======================================================================
Conversion from Two's Complement

Use the number 0xFFFFFFFF as an example. In binary, that is:

1111 1111 1111 1111 1111 1111 1111 1111

What can we say about this number? It's first (leftmost) bit is 1, which means that this represents a number that is negative. That's just the way that things are in two's complement: a leading 1 means the number is negative, a leading 0 means the number is 0 or positive.

To see what this number is a negative of, we reverse the sign of this number. But how to do that? The class notes say (on 3.17) that to reverse the sign you simply invert the bits (0 goes to 1, and 1 to 0) and add one to the resulting number.

The inversion of that binary number is, obviously:

0000 0000 0000 0000 0000 0000 0000 0000

Then we add one.

0000 0000 0000 0000 0000 0000 0000 0001

So the negative of 0xFFFFFFFF is 0x00000001, more commonly known as 1. So 0xFFFFFFFF is -1.
======================================================================
======================================================================
Division algorithm
https://en.m.wikipedia.org/wiki/Division_algorithm

Discussion will refer to the form {\displaystyle N/D=(Q,R)}N/D=(Q,R), where

N = Numerator (dividend)
D = Denominator (divisor)
is the input, and

Q = Quotient
R = Remainder
is the output.

Euclidean division

Finds the remainder given two positive integers using only subtractions and comparisons:

while N ≥ D do
  N := N − D
end
return N

Complete division algorithm using additions, subtractions, and comparisons:

function divide(N, D)
  if D = 0 then error(DivisionByZero) end
  if D < 0 then (Q, R) := divide(N, −D); return (−Q, R) end
  if N < 0 then
    (Q,R) := divide(−N, D)
    if R = 0 then return (−Q, 0)
    else return (−Q − 1, D − R) end
  end
  -- At this point, N ≥ 0 and D > 0
  return divide_unsigned(N, D)
end  
function divide_unsigned(N, D)
  Q := 0; R := N
  while R ≥ D do
    Q := Q + 1
    R := R − D
  end
  return (Q, R)
end

This procedure always produces R ≥ 0. Although very simple, it takes Ω(Q) steps, and so is exponentially slower than even slow division algorithms like long division.

Long division

Integer division (unsigned) with remainder

The following algorithm, the binary version of the famous long division, will divide N by D, placing the quotient in Q and the remainder in R. In the following code, all values are treated as unsigned integers.

if D = 0 then error(DivisionByZeroException) end
Q := 0                  -- Initialize quotient and remainder to zero
R := 0                     
for i := n − 1 .. 0 do  -- Where n is number of bits in N
  R := R << 1           -- Left-shift R by 1 bit
  R(0) := N(i)          -- Set the least-significant bit of R equal to bit i of the numerator
  if R ≥ D then
    R := R − D
    Q(i) := 1
  end
end
======================================================================
16-Bit Multiplication, HOWTO :-)
http://forum.6502.org/viewtopic.php?t=447

Here's the shift-and-add. When you start, one 16-bit number will be in 50-51, low byte first as usual for 6502, and the other 16-bit number will be in 52-53, same way. When you're done, the 32-bit answer will take all four bytes, with the high cell first. IOW, $12345678 will be in the order 34 12 78 56. Addresses 54 and 55 will be used as a scratchpad.

    LDA  52    ; Get the multiplicand and
    STA  54    ; put it in the scratchpad.
    LDA  53
    STA  55
    STZ  52    ; Zero-out the original multiplicand area.
    STZ  53

    LDY  #10H  ; We'll loop 16 times.
1$: ASL  52    ; Shift the entire 32 bits over one bit position.
    ROL  53
    ROL  50
    ROL  51
    BCC  2$    ; Skip the adding-in to the result if
               ; the high bit shifted out was 0.
    CLC        ; Else, add multiplier to intermediate result.
    LDA  54
    ADC  52
    STA  52
    LDA  55
    ADC  53
    STA  53

    LDA  #0    ; If C=1, incr lo byte of hi cell.
    ADC  50
    STA  50

2$: DEY        ; If we haven't done 16 iterations yet,
    BNE  1$    ; then go around again.

    RTS
 ;---------------------
======================================================================
mod and div implemented in 6502 asm
https://gist.github.com/hausdorff/5993556

math.asm (Euclidean division?)

; load some data up
LDA #$7
STA $00    ; memory addr A
LDA #$05
STA $01    ; memory addr B
JMP Divide

  	;modulus, returns in register A
Mod:
		LDA $00  ; memory addr A
		SEC
Modulus:	SBC $01  ; memory addr B
		BCS Modulus
		ADC $01
 
		;division, rounds up, returns in reg A
Division:
		LDA $00
		LDX #0
		SEC
Divide:		INX
		SBC $01
		BCS Divide
		TXA      ;get result into accumulator

======================================================================
Faster divmod by 10
https://www.reddit.com/r/beneater/comments/hhq6tq/faster_divmod_by_10/

How does it work?
Dividing a 16-bit number value by 10 is equivalent to (value*0xCCCD) >> 19 (using a full 16x16->32 multiply). Since the 6502 has no multiply instruction, we can instead manually decompose the multiply into shifts and adds.

Once we have the quotient, there are a few ways to compute the remainder. It turns out the bits we discarded from the multiply contain enough information to determine the remainder, so we can build a lookup table using those.

Is this actually useful?
Well if you want to convert binary to decimal, there's a different faster algorithm for that specifically, but if for some reason you really need to divide by 10 and find the remainder, this works.

6502_divmod10.s

value = $0200 ; 2 bytes

; tmp1 is (tmp1H):Y:X
tmp1H = $0202 ; 1 bytes
tmp2 = $0203 ; 3 bytes

MOD10_LUT:
  .byte 0
  .byte 1
  .byte FF
  .byte 2
  .byte 3
  .byte 3
  .byte 4
  .byte FF
  .byte 5
  .byte 6
  .byte FF
  .byte 7
  .byte 8
  .byte 8
  .byte 9
  .byte FF

  ; tmp1 <- value << 1 (==  value * 2)
  LDA value
  ASL
  TAX
  LDA value+1
  ROL
  TAY
  LDA #$0
  ROL
  STA tmp1H
  
  ; tmp1 <- tmp1 + value (== value * 3)
  ; CLC -- carry is already 0 from ROL
  TXA
  ADC value
  TAX
  TYA
  ADC value+1
  TAY
  BCC l1
  INC tmp1H
l1:
  
  ; tmp1 <- tmp1 << 2 (== value * 0xC)
  TXA
  ASL
  TAX
  TYA
  ROL
  TAY
  ROL tmp1H
  TXA
  ASL
  TAX
  TYA
  ROL
  TAY
  ROL tmp1H
  
  ; tmp2 <- tmp1 << 1 (== value * 0x18)
  TXA
  ASL
  STA tmp2
  TYA
  ROL
  STA tmp2+1
  LDA tmp1H
  ROL
  STA tmp2+2
  
  ; tmp2 <- tmp2 << 3 (== value * 0xC0)
  ASL tmp2
  ROL tmp2+1
  ROL tmp2+2
  ASL tmp2
  ROL tmp2+1
  ROL tmp2+2
  ASL tmp2
  ROL tmp2+1
  ROL tmp2+2
  
  ; tmp2 <- tmp2 + tmp1 (== value * 0xCC)
  ; CLC -- carry is already 0 from ROL
  TXA
  ADC tmp2
  STA tmp2
  TYA
  ADC tmp2+1
  STA tmp2+1
  LDA tmp1H
  ADC tmp2+2
  STA tmp2+2
  
  ; tmp1 <- (tmp2 + value) >> 8 (== (value * 0xCD) >> 8)
  ; CLC -- carry is already 0 from ADC
  LDA tmp2
  ADC value
  LDA tmp2+1
  ADC value+1
  TAX
  LDA tmp2+2
  ADC #$0
  TAY
  
  ; value[1]:Y:X <- tmp1 + tmp2 (== (value * 0xCCCD) >> 8)
  ; CLC -- carry is already 0 from ADC
  TXA
  ADC tmp2
  TAX
  TYA
  ADC tmp2+1
  TAY
  LDA #$0
  ADC tmp2+2
  STA value+1
  
  ; X <- (((Y:X) << 1) >> 8) & 0xF (== ((value * 0xCCCD) >> 15) & 0xF)
  TXA
  ASL
  TYA
  ROL
  AND #$0F
  TAX

  ; value <- value[1]:Y >> 3 (== (value * 0xCCCD) >> 19) (== value / 10)
  TYA
  LSR value+1
  ROR
  LSR value+1
  ROR
  LSR value+1
  ROR
  STA value
  
  ; A <- MOD10_LUT[X]
  LDA MOD10_LUT,X
  
  ; DONE!
  ; A     == value % 10
  ; value == value / 10

======================================================================
Binary to decimal can’t be that hard, right? | Ben Eater
https://old.reddit.com/r/ECE/comments/hgvgar/binary_to_decimal_cant_be_that_hard_right_ben/fw6b7ml/

Also, using an algorithm from the "Hacker's Delight" book (https://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685), you can do a divide by 10 using the following, which consists of only SHIFT, ADD, SUBTRACT operations.

uint32_t divu10hd(uint32_t n)

{

unsigned q, r;

q = (n >> 1) + (n >> 2);

q = q + (q >> 4);

q = q + (q >> 8);

q = q + (q >> 16);

q = q >> 3;

r = n - ((q << 3) + (q << 1)); // alternative for "n - (q times 10)", so won't need multiply instruction

return q + ((r + 6u) >> 4);

}

in the above code

q times 10

is converted into

(q times 8) + (q times 2)

which is translated into

(q << 3) + (q << 1)

and works with any processor!

======================================================================
6502 Coding Algorithms
http://www.obelisk.me.uk/6502/algorithms.html
======================================================================
### Addition & Subtraction

The 6502 processor provides 8 bit addition and subtraction instructions and a carry/borrow flag that is used to propagate the carry bit between operations.

To implement a 16 bit addition the programmer must code two pairs of additions; one for the least significant bytes and one for the most significant bytes. The carry flag must be cleared before the first addition to ensure that an additional increment isn't performed.

; 16 bit Binary Addition
        CLC             ;Ensure carry is clear
        LDA VLA+0       ;Add the two least significant bytes
        ADC VLB+0
        STA RES+0       ;... and store the result
        LDA VLA+1       ;Add the two most significant bytes
        ADC VLB+1       ;... and any propagated carry bit
        STA RES+1       ;... and store the result

Subtraction follows the same pattern but the carry must be set before the first pair of bytes are subtracted to get the correct result.

; 16 bit Binary Subtraction
        SEC             ;Ensure carry is set
        LDA VLA+0       ;Subtract the two least significant bytes
        SBC VLB+0
        STA RES+0       ;... and store the result
        LDA VLA+1       ;Subtract the two most significant bytes
        SBC VLB+1       ;... and any propagated borrow bit
        STA RES+1       ;... and store the result

Both the addition and subtraction algorithm can be extended to 32 bits by repeating the LDA/ADC/STA or LDA/SBC/STA pattern for two further bytes worth of data.

### Negation

The traditional approach to negating a twos complement number is to reverse all the bits (by EORing with $FF) and add one as shown below.

; 8 bit Binary Negation
        CLC 		;Ensure carry is clear
	EOR #$FF	;Invert all the bits
	ADC #1		;... and add one

This technique works well with a single byte already held in the accumulator but not with bigger numbers. With these it is easier just to subtract them from zero.

; 16 bit Binary Negation
        SEC             ;Ensure carry is set
        LDA #0          ;Load constant zero
        SBC SRC+0       ;... subtract the least significant byte
        STA DST+0       ;... and store the result
        LDA #0          ;Load constant zero again
        SBC SRC+1       ;... subtract the most significant byte
        STA DST+1       ;... and store the result
======================================================================
maclib.inc
======================================================================
		NOLIST
;------------------------------------------------
; 6502 Standard Macro Library
;------------------------------------------------
; Copyright (C),1999 Andrew John Jacobs.
; All rights reserved.
;------------------------------------------------

;------------------------------------------------
; Revision History:
;
; 16-Aug-99 AJJ	Initial version.
;
; 14-Nov-01 AJJ Finally got around to filling in
;		some missing comments.
;
;------------------------------------------------

; Notes:
;
; This file contains a number of useful 6502
; algorithms for number, string and memory
; operations. The code is written in the form of
; macros rather than subroutines to make them
; more flexible.
;
; The routines in the library assume that 16 and
; 32 bit numbers are represented in little endian
; order, that is the least significant byte in
; the lowest memory location, so that they can
; be applied to addresses as well as pure
; numbers.
;
; The string routines assume that they are
; working with null terminated 'C' style strings.
;
; The main routines sacrifice code size for speed
; and are coded without any iteration. Compact
; versions which use iteration are provided for
; some algorithms and have the same name as the
; original routine with a 'C' suffix (eg. _XFR32
; => _XFR32C).
;
; Some of the macros use 65SC02 instructions for
; speed or to reduce the amount code generated if
; the assembler will accept them.
;
; Where possible the macros detect optimizable
; cases and generate more efficient code.
;
; Bugs & Enhancments:
;
; If you find a bug I missed or have a new
; routine you would like to submit to the library
; then mail me at:
;
; Andrew@obelisk.demon.co.uk

		PAGE
;------------------------------------------------
; Basic Operations
;------------------------------------------------

; Clear 2 bytes of memory at any location by
; setting it to zero. If 65SC02 instructions are
; available then STZ is used.
;
; On exit: A = ??, X & Y are unchanged.

		IF __65SC02__
_CLR16		 MACRO MEM
		 STZ MEM+0
		 STZ MEM+1
		 ENDM
		ELSE
_CLR16		 MACRO MEM
		 LDA #0
		 STA MEM+0
		 STA MEM+1
		 ENDM
		ENDIF

; Clear 4 bytes of memory at any location by
; setting it to zero. If 65SC02 instructions are
; available then STZ is used.
;
; On exit: A = ??, X & Y are unchanged.

		IF __65SC02__
_CLR32		 MACRO MEM
		 STZ MEM+0
		 STZ MEM+1
		 STZ MEM+2
		 STZ MEM+3
		 ENDM
		ELSE
_CLR32		 MACRO MEM
		 LDA #0
		 STA MEM+0
		 STA MEM+1
		 STA MEM+2
		 STA MEM+3
		 ENDM
		ENDIF

; Clear 4 bytes of memory at any location by
; setting it to zero iteratively. If 65SC02
; instructions are available then STZ is used.
;
; On exit: A = ??, X = $FF, Y is unchanged.

		IF __65SC02__
_CLR32C		 MACRO MEM
		 LDX #3
_LOOP\?		 STZ MEM,X
		 DEX
		 BPL _LOOP\?
		 ENDM
		ELSE
_CLR32C		 MACRO MEM
		 LDA #0
		 LDX #3
_LOOP\?		 STA MEM,X
		 DEX
		 BPL _LOOP\?
		 ENDM
		ENDIF

; Transfer 2 bytes of memory from one location to
; another using the accumulator. The order in
; which the bytes are moved depends on the
; relative positions of SRC and DST. If SRC and
; DST are the same then no code is generated.
;
; On exit: A = ??, X & Y are unchanged.

_XFR16		MACRO SRC,DST
		IF SRC != DST
		 IF SRC > DST
		  LDA SRC+0
		  STA DST+0
		  LDA SRC+1
		  STA DST+1
		 ELSE
		  LDA SRC+1
		  STA DST+1
		  LDA SRC+0
		  STA DST+0
		 ENDIF
		ENDIF
		ENDM

; Transfer 4 bytes of memory from one location to
; another using the accumulator. The order in
; which the bytes are moved depends on the
; relative positions of SRC and DST. If SRC and
; DST are the same then no code is generated.
;
; On exit: A = ??, X & Y are unchanged.

_XFR32		MACRO SRC,DST
		IF SRC != DST
		 IF SRC > DST
		  LDA SRC+0
		  STA DST+0
		  LDA SRC+1
		  STA DST+1
		  LDA SRC+2
		  STA DST+2
		  LDA SRC+3
		  STA DST+3
		 ELSE
		  LDA SRC+3
		  STA DST+3
		  LDA SRC+2
		  STA DST+2
		  LDA SRC+1
		  STA DST+1
		  LDA SRC+0
		  STA DST+0
		 ENDIF
		ENDIF
		ENDM

; Transfer 4 bytes of memory from one location to
; another iteratively using the accumulator. The
; transfer may fail if SRC and DST overlap. If
; SRC and DST are the same then no code is
; generated.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_XFR32C		MACRO SRC,DST
		IF SRC != DST
		 LDX #3
_LOOP\?		 LDA SRC,X
		 STA DST,X
		 DEX
		 BPL _LOOP\?
		ENDIF
		ENDM

; Set the value of a 16 bit location DST with
; the given constant value.
;
; On exit: A = ??, X & Y unchanged.

_SET16I		MACRO NUM,DST
		IF NUM != 0
		 LDA #LO NUM
		 STA DST+0
		 LDA #HI NUM
		 STA DST+1
		ELSE
		 _CLR16 DST
		ENDIF

		PAGE
;------------------------------------------------
; Logical Operations
;------------------------------------------------

; Calculate the logical NOT of the 16 bit value
; at location VLA and stores it in location RES.
;
; On exit: A = ??, X & Y are unchanged.

_NOT16		MACRO VLA,RES
		LDA VLA+0
		EOR #$FF
		STA RES+0
		LDA VLA+1
		EOR #$FF
		STA RES+1
		ENDM

; Calculate the logical NOT of the 32 bit value
; at location VLA and stores it in location RES.
;
; On exit: A = ??, X & Y are unchanged.

_NOT32		MACRO VLA,RES
		LDA VLA+0
		EOR #$FF
		STA RES+0
		LDA VLA+1
		EOR #$FF
		STA RES+1
		LDA VLA+2
		EOR #$FF
		STA RES+2
		LDA VLA+3
		EOR #$FF
		STA RES+3
		ENDM

; Calculate the logical NOT of the 32 bit value
; at location VLA iteratively and stores it in
; location RES.
;
; On exit: A = ??, X = $FF, Y are unchanged.

_NOT32C		MACRO VLA,RES
		LDX #3
_LOOP\?		LDA VLA,X
		EOR #$FF
		STA RES,X
		DEX
		BPL _LOOP\?
		ENDM

; Calculate the logical OR of the two 16 bit
; values at locations VLA and VLB. The result is
; stored in location RES. If VLA and VLB are the
; same the macro expands to a _XFR16.
;
; On exit: A = ??, X & Y are unchanged.

_ORA16		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDA VLA+0
		 ORA VLB+0
		 STA RES+0
		 LDA VLA+1
		 ORA VLB+1
		 STA RES+1
		ELSE
		 _XFR16 VLA,RES
		ENDIF
		ENDM

; Calculate the logical OR of a 16 value at
; location VLA with a constant value and
; store the result at location RES.
;
; On exit: A = ??, X & Y are unchanged.

_ORA16I		MACRO VLA,NUM,RES
		 LDA VLA+0
		 ORA #LO NUM
		 STA RES+0
		 LDA VLA+1
		 ORA #HI NUM
		 STA RES+1
		ENDM

; Calculate the logical OR of the two 32 bit
; values at locations VLA and VLB. The result is
; stored in location RES. If VLA and VLB are the
; same the macro expands to a _XFR32.
;
; On exit: A = ??, X & Y are unchanged.

_ORA32		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDA VLA+0
		 ORA VLB+0
		 STA RES+0
		 LDA VLA+1
		 ORA VLB+1
		 STA RES+1
		 LDA VLA+2
		 ORA VLB+2
		 STA RES+2
		 LDA VLA+3
		 ORA VLB+3
		 STA RES+3
		ELSE
		 _XFR32 VLA,RES
		ENDIF
		ENDM

; Calculate the logical OR of the two 32 bit
; values at locations VLA and VLB iteratively.
; The result is stored in location RES. If VLA
; and VLB are the same the macro expands to a
; _XFR32C.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_ORA32C		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDX #3
_LOOP\?		 LDA VLA,X
		 ORA VLB,X
		 STA RES,X
		 DEX
		 BPL _LOOP\?
		ELSE
		 _XFR32C VLA,RES
		ENDIF
		ENDM

; Calculate the logical AND of the two 16 bit
; values at locations VLA and VLB. The result is
; stored in location RES. If VLA and VLB are the
; same the macro expands to a _XFR16.
;
; On exit: A = ??, X & Y are unchanged.

_AND16		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDA VLA+0
		 AND VLB+0
		 STA RES+0
		 LDA VLA+1
		 AND VLB+1
		 STA RES+1
		ELSE
		 _XFR16 VLA,RES
		ENDIF
		ENDM

; Calculate the logical AND of a 16 value at
; location VLA with a constant value and
; store the result at location RES.
;
; On exit: A = ??, X & Y are unchanged.

_AND16I		MACRO VLA,NUM,RES
		 LDA VLA+0
		 AND #LO NUM
		 STA RES+0
		 LDA VLA+1
		 AND #HI NUM
		 STA RES+1
		ENDM

; Calculate the logical AND of the two 32 bit
; values at locations VLA and VLB. The result is
; stored in location RES. If VLA and VLB are the
; same the macro expands to a _XFR32.
;
; On exit: A = ??, X & Y are unchanged.

_AND32		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDA VLA+0
		 AND VLB+0
		 STA RES+0
		 LDA VLA+1
		 AND VLB+1
		 STA RES+1
		 LDA VLA+2
		 AND VLB+2
		 STA RES+2
		 LDA VLA+3
		 AND VLB+3
		 STA RES+3
		ELSE
		 _XFR32 VLA,RES
		ENDIF
		ENDM

; Calculate the logical AND of the two 32 bit
; values at locations VLA and VLB iteratively.
; The result is stored in location RES. If VLA
; and VLB are the same the macro expands to a
; _XFR32C.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_AND32C		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDX #3
_LOOP\?		 LDA VLA,X
		 AND VLB,X
		 STA RES,X
		 DEX
		 BPL _LOOP\?
		ELSE
		 _XFR32C VLA,RES
		ENDIF
		ENDM

; Calculate the exclusive OR of the two 16 bit
; values at locations VLA and VLB. The result is
; stored in location RES. If VLA and VLB are the
; same the macro expands to a _CLR16.
;
; On exit: A = ??, X & Y are unchanged.

_EOR16		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDA VLA+0
		 EOR VLB+0
		 STA RES+0
		 LDA VLA+1
		 EOR VLB+1
		 STA RES+1
		ELSE
		 _CLR16 RES
		ENDIF
		ENDM

; Calculate the exclusive OR of a 16 value at
; location VLA with a constant value and
; store the result at location RES.
;
; On exit: A = ??, X & Y are unchanged.

_EOR16I		MACRO VLA,NUM,RES
		 LDA VLA+0
		 EOR #LO NUM
		 STA RES+0
		 LDA VLA+1
		 EOR #HI NUM
		 STA RES+1
		ENDM

; Calculate the exclusive OR of the two 32 bit
; values at locations VLA and VLB. The result is
; stored in location RES. If VLA and VLB are the
; same the macro expands to a _CLR32.
;
; On exit: A = ??, X & Y are unchanged.

_EOR32		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDA VLA+0
		 EOR VLB+0
		 STA RES+0
		 LDA VLA+1
		 EOR VLB+1
		 STA RES+1
		 LDA VLA+2
		 EOR VLB+2
		 STA RES+2
		 LDA VLA+3
		 EOR VLB+3
		 STA RES+3
		ELSE
		 _CLR32 RES
		ENDIF
		ENDM

; Calculate the exclusive OR of the two 32 bit
; values at locations VLA and VLB iteratively.
; The result is stored in location RES. If VLA
; and VLB are the same the macro expands to a
; _XFR32C.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_EOR32C		MACRO VLA,VLB,RES
		IF VLA != VLB
		 LDX #3
_LOOP\?		 LDA VLA,X
		 EOR VLB,X
		 STA RES,X
		 DEX
		 BPL _LOOP\?
		ELSE
		 _CLR32C RES
		ENDIF
		ENDM

		PAGE
;------------------------------------------------
; Shift Operations
;------------------------------------------------

; Perform an arithmetic shift left on the 16 bit
; number at location VLA and store the result at
; location RES. If VLA and RES are the same then
; the operation is applied directly to the memory
; otherwise it is done in the accumulator.
;
; On exit: A = ??, X & Y are unchanged.

_ASL16		MACRO VLA,RES
		IF VLA != RES
		 LDA VLA+0
		 ASL A
		 STA RES+0
		 LDA VLA+1
		 ROL A
		 STA RES+1
		ELSE
		 ASL VLA+0
		 ROL VLA+1
		ENDIF
		ENDM

; Perform an arithmetic shift left on the 32 bit
; number at location VLA and store the result at
; location RES. If VLA and RES are the same then
; the operation is applied directly to the memory
; otherwise it is done in the accumulator.
;
; On exit: A = ??, X & Y are unchanged.

_ASL32		MACRO VLA,RES
		IF VLA != RES
		 LDA VLA+0
		 ASL A
		 STA RES+0
		 LDA VLA+1
		 ROL A
		 STA RES+1
		 LDA VLA+2
		 ROL A
		 STA RES+2
		 LDA VLA+3
		 ROL A
		 STA RES+3
		ELSE
		 ASL VLA+0
		 ROL VLA+1
		 ROL VLA+2
		 ROL VLA+3
		ENDIF
		ENDM

; Perform a left rotation on the 16 bit number at
; location VLA and store the result at location
; RES. If VLA and RES are the same then the
; operation is applied directly to the memory,
; otherwise it is done in the accumulator.
;
; On exit: A = ??, X & Y are unchanged.

_ROL16		MACRO VLA,RES
		IF VLA != RES
		 LDA VLA+0
		 ROL A
		 STA RES+0
		 LDA VLA+1
		 ROL A
		 STA RES+1
		ELSE
		 ROL VLA+0
		 ROL VLA+1
		ENDIF
		ENDM

; Perform a left rotation on the 32 bit number at
; location VLA and store the result at location
; RES. If VLA and RES are the same then the
; operation is applied directly to the memory,
; otherwise it is done in the accumulator.
;
; On exit: A = ??, X & Y are unchanged.

_ROL32		MACRO VLA,RES
		IF VLA != RES
		 LDA VLA+0
		 ROL A
		 STA RES+0
		 LDA VLA+1
		 ROL A
		 STA RES+1
		 LDA VLA+2
		 ROL A
		 STA RES+2
		 LDA VLA+3
		 ROL A
		 STA RES+3
		ELSE
		 ROL VLA+0
		 ROL VLA+1
		 ROL VLA+2
		 ROL VLA+3
		ENDIF
		ENDM

; Perform an logical shift right on the 16 bit
; number at location VLA and store the result at
; location RES. If VLA and RES are the same then
; the operation is applied directly to the memory
; otherwise it is done in the accumulator.
;
; On exit: A = ??, X & Y are unchanged.

_LSR16		MACRO VLA,RES
		IF VLA != RES
		 LDA VLA+1
		 LSR A
		 STA RES+1
		 LDA VLA+0
		 ROR A
		 STA RES+0
		ELSE
		 LSR VLA+1
		 ROR VLA+0
		ENDIF
		ENDM

; Perform an logical shift right on the 32 bit
; number at location VLA and store the result at
; location RES. If VLA and RES are the same then
; the operation is applied directly to the memory
; otherwise it is done in the accumulator.
;
; On exit: A = ??, X & Y are unchanged.

_LSR32		MACRO VLA,RES
		IF VLA != RES
		 LDA VLA+3
		 LSR A
		 STA RES+3
		 LDA VLA+2
		 ROR A
		 STA RES+2
		 LDA VLA+1
		 ROR A
		 STA RES+1
		 LDA VLA+0
		 ROR A
		 STA RES+0
		ELSE
		 LSR VLA+3
		 ROR VLA+2
		 ROR VLA+1
		 ROR VLA+0
		ENDIF
		ENDM

; Perform a right rotation on the 16 bit number
; at location VLA and store the result at
; location RES. If VLA and RES are the same then
; the operation is applied directly to the memory
; otherwise it is done in the accumulator.
;
; On exit: A = ??, X & Y are unchanged.

_ROR16		MACRO VLA,RES
		IF VLA != RES
		 LDA VLA+1
		 ROR A
		 STA RES+1
		 LDA VLA+0
		 ROR A
		 STA RES+0
		ELSE
		 ROR VLA+1
		 ROR VLA+0
		ENDIF
		ENDM

; Perform a right rotation on the 32 bit number
; at location VLA and store the result at
; location RES. If VLA and RES are the same then
; the operation is applied directly to the memory
; otherwise it is done in the accumulator.
;
; On exit: A = ??, X & Y are unchanged.

_ROR32		MACRO VLA,RES
		IF VLA != RES
		 LDA VLA+3
		 ROR A
		 STA RES+3
		 LDA VLA+2
		 ROR A
		 STA RES+2
		 LDA VLA+1
		 ROR A
		 STA RES+1
		 LDA VLA+0
		 ROR A
		 STA RES+0
		ELSE
		 ROR VLA+3
		 ROR VLA+2
		 ROR VLA+1
		 ROR VLA+0
		ENDIF
		ENDM

		PAGE
;------------------------------------------------
; Arithmetic Operations
;------------------------------------------------

; Increment the 16 bit value at location MEM
; by one.
;
; On exit: A, X & Y are unchanged.

_INC16		MACRO MEM
		INC MEM+0
		BNE _DONE\?
		INC MEM+1
_DONE\?		EQU *
		ENDM

; Increment the 32 bit value at location MEM
; by one.
;
; On exit: A, X & Y are unchanged.

_INC32		MACRO MEM
		INC MEM+0
		BNE _DONE\?
		INC MEM+1
		BNE _DONE\?
		INC MEM+2
		BNE _DONE\?
		INC MEM+3
_DONE\?		EQU *
		ENDM

; Decrement the 16 bit value at location MEM
; by one.
;
; On exit: A = ??, X & Y are unchanged.

_DEC16		MACRO MEM
		LDA MEM+0
		BNE _DONE\?
		DEC MEM+1
_DONE\?		DEC MEM+0
		ENDM

; Decrement the 32 bit value at location MEM
; by one.
;
; On exit: A = ??, X & Y are unchanged.

_DEC32		MACRO MEM
		LDA MEM+0
		BNE _DEC0\?
		LDA MEM+1
		BNE _DEC1\?
		LDA MEM+2
		BNE _DEC2\?
		DEC MEM+3
_DEC2\?		DEC MEM+2
_DEC1\?		DEC MEM+1
_DEC0\?		DEC MEM+0
		ENDM

; Add two 16 bit numbers together and store the
; result in another memory location. RES may be
; the same as either VLA or VLB.
;
; On exit: A = ??, X & Y are unchanged.

_ADD16		MACRO VLA,VLB,RES
		IF VLA != VLB
	 	 CLC
	 	 LDA VLA+0
		 ADC VLB+0
		 STA RES+0
		 LDA VLA+1
		 ADC VLB+1
		 STA RES+1
		ELSE
		 _ASL16 VLA,RES
		ENDIF
		ENDM

; Add two 32 bit numbers together and store the
; result in another memory location. RES may be
; the same as either VLA or VLB.
;
; On exit: A = ??, X & Y are unchanged.

_ADD32		MACRO VLA,VLB,RES
		IF VLA != VLB
		 CLC
		 LDA VLA+0
		 ADC VLB+0
		 STA RES+0
		 LDA VLA+1
		 ADC VLB+1
		 STA RES+1
		 LDA VLA+2
		 ADC VLB+2
		 STA RES+2
		 LDA VLA+3
		 ADC VLB+3
		 STA RES+3
		ELSE
		 _ASL32 VLA,RES
		ENDIF
		ENDM

; Subtract two 16 bit numbers and store the
; result in another memory location. RES may be
; the same as VLA or VLB.
;
; On exit: A = ??, X & Y are unchanged.

_SUB16		MACRO VLA,VLB,RES
		SEC
		LDA VLA+0
		SBC VLB+0
		STA RES+0
		LDA VLA+1
		SBC VLB+1
		STA RES+1
		ENDM

; Subtract two 32 bit numbers and store the
; result in another memory location. RES may be
; the same as VLA or VLB.
;
; On exit: A = ??, X & Y are unchanged.

_SUB32		MACRO VLA,VLB,RES
		SEC
		LDA VLA+0
		SBC VLB+0
		STA RES+0
		LDA VLA+1
		SBC VLB+1
		STA RES+1
		LDA VLA+2
		SBC VLB+2
		STA RES+2
		LDA VLA+3
		SBC VLB+3
		STA RES+3
		ENDM

; Negate the signed 16 bit number at location VLA
; and stored the result at location RES. RES may
; be the same as VLA.
;
; On exit: A = ??, X & Y are unchanged.

_NEG16		MACRO VLA,RES
		SEC
		LDA #0
		SBC VLA+0
		STA RES+0
		LDA #0
		SBC VLA+1
		STA RES+1
		ENDM

; Negate the signed 32 bit number at location VLA
; and stored the result at location RES. RES may
; be the same as VLA.
;
; On exit: A = ??, X & Y are unchanged.

_NEG32		MACRO VLA,RES
		SEC
		LDA #0
		SBC VLA+0
		STA RES+0
		LDA #0
		SBC VLA+1
		STA RES+1
		LDA #0
		SBC VLA+2
		STA RES+2
		LDA #0
		SBC VLA+3
		STA RES+3
		ENDM

; Calculates the absolute value of signed 16 bit
; number at location VLA and stores it in the RES
; location. Less code is generated if VLA and RES
; are the same location. If 65SC02 instructions
; are available a BRA is used to shorten the
; generated code.
;
; On exit: A = ??, X & Y are unchanged.

_ABS16		MACRO VLA,RES
		BIT VLA+0
		IF VLA != RES
		 BPL _MOVE\?
		 _NEG16 VLA,RES
		 IF __65SC02__
		  BRA _DONE\?
		 ELSE
		  JMP _DONE\?
		 ENDIF
_MOVE\?		 EQU *
		 _XFR16 VLA,RES
		ELSE
		 BPL _DONE\?
		 _NEG16 VLA,RES
		ENDIF
_DONE\?		EQU *
		ENDM

; Calculates the absolute value of signed 32 bit
; number at location VLA and stores it in the RES
; location. Less code is generated if VLA and RES
; are the same location. If 65SC02 instructions
; are available a BRA is used to shorten the
; generated code.
;
; On exit: A = ??, X & Y are unchanged.

_ABS32		MACRO VLA,RES
		BIT VLA+0
		IF VLA != RES
		 BPL _MOVE\?
		 _NEG32 VLA,RES
		 IF __65SC02__
		  BRA _DONE\?
		 ELSE
		  JMP _DONE\?
		 ENDIF
_MOVE\?		 EQU *
		 _XFR32 VLA,RES
		ELSE
		 BPL _DONE\?
		 _NEG32 VLA,RES
		ENDIF
_DONE\?		EQU *
		ENDM

; Calculate the 16 bit product of two 16 bit
; unsigned numbers. Any overflow during the
; calculation is lost. The number at location
; VLA is destroyed.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_MUL16		MACRO VLA,VLB,RES
		_CLR16 RES
		LDX #16
_LOOP\?		EQU *
		_ASL16 RES,RES
		_ASL16 VLA,VLA
		BCC _NEXT\?
		_ADD16 VLB,RES,RES
_NEXT\?		DEX
		BPL _LOOP\?
		ENDM

; Calculate the 32 bit product of two 16 bit
; unsigned numbers. The number at location VLA
; is destroyed.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_MUL16X		MACRO VLA,VLB,RES
		_CLR32 RES
		LDX #16
_LOOP\?		EQU *
		_ASL32 RES,RES
		_ASL16 VLA,VLA
		BCC _NEXT\?
		_ADD16 VLB,RES,RES
		BCC _NEXT\?
		_INC16 RES+2
_NEXT\?		EQU *
		DEX
		BPL _LOOP\?
		ENDM

; Calculate the 32 bit product of two 32 bit
; unsigned numbers. Any overflow during the
; calculation is lost. The number at location
; VLA is destroyed.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_MUL32		MACRO VLA,VLB,RES
		_CLR32 RES
		LDX #32
_LOOP\?		EQU *
		_ASL32 RES,RES
		_ASL32 VLA,VLA
		BCC _NEXT\?
		_ADD32 VLB,RES,RES
_NEXT\?		EQU *
		DEX
		BPL _LOOP\?
		ENDM

; These two macros write the code necessary
; to multiply a 16 bit at location VLA by
; a 16 bit constant NUM and store the 16 bit
; result in location RES.
;
; On exit: A = ??, X & Y unchanged.

_MUL16I		MACRO VLA,NUM,RES
		IF NUM = 1
		 _XFR16 VLA,RES
		ELSE
		 _CLR16 RES
		 __MUL16I VLA,NUM,RES
		ENDIF
		ENDM

__MUL16I	MACRO VLA,NUM,RES
		 IF NUM & $FFFE
		  __MUL16I VLA,(NUM/2),RES
		  _ASL16 RES,RES
		 ENDIF
		 IF NUM & $0001
		   _ADD16 VLA,RES,RES
		 ENDIF
		ENDM

; Divide the 16 bit number at location VLA
; by the 16 bit number at location VLB
; leaving the 16 bit quotient at QUO and
; the 16 bit remainder in REM. The value in
; location VLA is destroyed.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_DIV16		MACRO VLA,VLB,QUO,REM
		_CLR16 REM
		LDX #16
_LOOP\?		EQU *
		_ASL16 VLA,VLA
		_ROL16 REM,REM
		_SUB16 REM,VLB,REM
		BCS _NEXT\?
		_ADD16 REM,VLB,REM
_NEXT\?		EQU *
		_ROL16 QUO,QUO
		DEX
		BPL _LOOP\?
		ENDM

; Divide the 32 bit number at location VLA
; by the 16 bit number at location VLB
; leaving the 16 bit quotient at QUO and
; the 16 bit remainder in REM. The value in
; location VLA is destroyed.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_DIV16X		MACRO VLA,VLB,QUO,REM
		_CLR16 REM
		LDX #32
_LOOP\?		EQU *
		_ASL32 VLA,VLA
		_ROL16 REM,REM
		_SUB16 REM,VLB,REM
		BCS _NEXT\?
		_ADD16 REM,VLB,REM
_NEXT\?		EQU *
		_ROL16 QUO,QUO
		DEX
		BPL _LOOP\?
		ENDM

; Divide the 32 bit number at location VLA
; by the 32 bit number at location VLB
; leaving the 32 bit quotient at QUO and
; the 32 bit remainder in REM. The value in
; location VLA is destroyed.
;
; On exit: A = ??, X = $FF, Y is unchanged.

_DIV32		MACRO VLA,VLB,QUO,REM
		_CLR32 REM
		LDX #32
_LOOP\?		EQU *
		_ASL32 VLA,VLA
		_ROL32 REM,REM
		_SUB32 REM,VLB,REM
		BCS _NEXT\?
		_ADD32 REM,VLB,REM
_NEXT\?		EQU *
		_ROL32 QUO,QUO
		DEX
		BPL _LOOP\?
		ENDM

		PAGE
;------------------------------------------------
; Comparative Operations
;------------------------------------------------

; Compares two 16 bit values in memory areas VLA
; and VLB. The comparison starts with the most
; significant bytes and returns as soon as a
; difference is detected.
;
; On exit: A = ??, X & Y are unchanged.

_CMP16		MACRO VLA,VLB
		LDA VLA+1
		CMP VLB+1
		BNE _DONE\?
		LDA VLA+0
		CMP VLB+0
_DONE\?		EQU *
		ENDM

; Compares two 32 bit values in memory areas VLA
; and VLB. The comparison starts with the most
; significant bytes and returns as soon as a
; difference is detected.
;
; On exit: A = ??, X & Y are unchanged.

_CMP32		MACRO VLA,VLB
		LDA VLA+3
		CMP VLB+3
		BNE _DONE\?
		LDA VLA+2
		CMP VLB+2
		BNE _DONE\?
		LDA VLA+1
		CMP VLB+1
		BNE _DONE\?
		LDA VLA+0
		CMP VLB+0
_DONE\?		EQU *
		ENDM

		PAGE
;------------------------------------------------
; Memory Operations
;------------------------------------------------

; Transfers a block of memory from one place to
; another by copying the bytes starting at the
; front of the block and going forward. SRC and
; DST are destroyed during the copy.
;
; On exit: A, X & Y = ??.

_MEMFWD		MACRO  SRC,DST,LEN
		LDY #0
		LDX LEN+1
		BEQ _FRAG\?
_PAGE\?		LDA (SRC),Y
		STA (DST),Y
		INY
		BNE _PAGE\?
		INC SRC+1
		INC DST+1
		DEX
		BNE _PAGE\?
_FRAG\?		CPY LEN+0
		BEQ _DONE\?
		LDA (SRC),Y
		STA (DST),Y
		INY
		BNE _FRAG\?
_DONE\?		EQU *
		ENDM

; Transfers a block of memory from one place to
; another by copying the bytes starting at the
; end of the block and going backwards.

_MEMREV		MACRO  SRC,DST,LEN
		NOP
		ENDM

; Tranfers a block of memory from one location to
; another. Depending on the relative positions of
; the blocks an appropriate transfer method is
; used.

_MEMCPY		MACRO  SRC,DST,LEN
		_CMP16 SRC,DST
		BCC _SAFE\?
		_MEMFWD SRC,DST,LEN
		IF __65SC02__
		 BRA _DONE\?
		ELSE
		 JMP _DONE\?
		ENDIF
_SAFE\?		_MEMREV SRC,DST,LEN
_DONE\?		EQU *
		ENDM

		PAGE
;------------------------------------------------
; String Operations
;------------------------------------------------

; Calculates length of a null terminated string
; by searching for its end. The address of the
; string in STR is destroyed during the search.
;
; On exit: A & Y = ??, X is unchanged.

_STRLEN		MACRO  STR,LEN
		LDY #0
		STY LEN+1
_LOOP\?		LDA (STR),Y
		BEQ _DONE\?
		INY
		BNE _LOOP\?
		INC LEN+1
		INC STR+1
		IF __65SC02__
		 BRA _LOOP\?
		ELSE
		 JMP _LOOP\?
		ENDIF
_DONE\?		STY LEN+0
		ENDM

; Copies a null terminated string from one memory
; location to another. The source and destination
; addresses are destroyed during the copy process.
;
; On exit: A & Y = ??, X is unchanged.

_STRCPY		MACRO SRC,DST
		LDY #0
_LOOP\?		LDA (SRC),Y
		STA (DST),Y
		BEQ _DONE\?
		INY
		BNE _LOOP\?
		INC SRC+1
		INC DST+1
		IF __65SC02__
		 BRA _LOOP\?
		ELSE
		 JMP _LOOP\?
		ENDIF
_DONE\?		EQU *
		ENDM

;

_STRCMP		MACRO VLA,VLB
		LDY #0
_LOOP\?		LDA (VLA),Y
		CMP (VLB),Y
		BNE _DONE\?
		LDA (VLA),Y
		BEQ _DONE\?
		INY
		BNE _LOOP\?
		INC VLA+1
		INC VLB+1
		IF __65SC02__
		 BRA _LOOP\?
		ELSE
		 JMP _LOOP\?
		ENDIF
_DONE\?		EQU *
		ENDM

;

_STRNCMP	MACRO VLA,VLB,LEN
		ENDM

		LIST
======================================================================
