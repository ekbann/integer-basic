.include "./includes/macros.inc"
.include "./includes/header.inc"

        ;PrintNewline

        ; FIX: print SIGNED integer part in PrFP32
;        LoadAddress S1          ; fixed-point string to r0
;        jsr atofp
;        jsr PrFP32
;        PrintNewline
;        PrintNewline

;        jsr FPSTACK
;        PrintNewline

;        LoadAddress S2          ; fixed-point string to r0
;        jsr atofp
;        jsr PrFP32
;        PrintNewline
;        PrintNewline

;        jsr FPSTACK
;        PrintNewline

        ; FIX: pad/truncate mantissa part to 8 chars padded with '0'
;        LoadAddress S3          ; fixed-point string to r0
;        jsr atofp
;        jsr PrFP32
;        PrintNewline
;        PrintNewline

        jsr FPSTACK
        PrintNewline

        ; TEST NEW xATOFP
        LoadAddress S3          ; fixed-point string to r0
        jsr xatofp
        jsr PrFP32
        PrintNewline

        jsr FPSTACK
        PrintNewline

        rts

;S1:     .asciiz "-123.456"     ; FAILS because mantissa becomes '0456'
S1:     .asciiz "-123.4560"     ; WORKS correctly, mantissa becomes '4560'
S2:     .asciiz "3.1415"        ; WORKS because 4 decimal numbers
;S3:     .asciiz "3.14159"       ; FAILS because "14159" overflows limit of "9999"
S3:     .asciiz "3.00001526"

BUFFER:

;
; Fixing ATOFP
;
xatofp:
	pha
	phx
	phy
	MoveW r0, r11	        ; move STRING pointer because r0 gets clobbered here
        ldy #0                  ; init buffer pointer
	StoreImm $0000, r0	; zero accumulator in TOS
	jsr PUSH		; clobbers r0!!!
        jsr xgettxtfp           ; grab a non-space buffer char
        cmp #'-'                ; leading minus sign?
        beq xatofp2             ;   yes: set sign bit in C
        clc                     ;   no : must be positive
        eor #'+'                ; leading plus sign?
        bne xatofp3             ;   no : go with an assumed '+'
xatofp2:
        iny                     ; skip over the '+' or '-' char
xatofp3:
        php                     ; save sgn (CS:'-' CC:'+'|none)
	  ;
	  ; NOW begins the main program to process integer:mantissa
	  ;
        dey                     ; back up one for first getnxt
xatofp4:
        jsr xgetnxtfp           ; grab next char, CHAR/DEC returned in .A
        bcs xatofp5             ; not a decimal digit, assume '.' and process mantissa
	jsr MUL10		; multiply TOS by 10
	sta r0L			; push digit to TOS
	stz r0H
	jsr PUSH
      			        ; (CC is assumed from context)
	jsr ADD			; add it to TOS
        bra xatofp4             ; try another digit
xatofp5:			; process mantissa after sign'ing integer
	;jsr CHROUT		; print '.' = YEP it does!	  
        plp                     ; retrieve sign
        bcc xatofp6             ;
	jsr NEG			; negate if applicable
xatofp6:	; done with integer part; .A has '.' or #$00 from .asciiz
	beq xatofpend		; end-of-string #$00 encountered
	StoreImm $0000, r0	; zero accumulator in TOS
	jsr PUSH		; clobbers r0!!!
        jsr PUSH        ; need another to merge the TWO separate mantissas (4-chars)
        ;
        ;phy     ; save .Y = string pointer to '.'
        ldx #0  ; reset index to mantissa buffer
copystart:
        iny                     ; point to next digit
        lda (r11),y             ; grab a char from text buffer
        beq copyend     ; EOS reached, end string copy
        sta mantissafp,x
        inx     ; point to next buffer digit
        bra copystart
copyend:
        ;ply     ; restore string pointer back to '.' - DOESN'T NEED because now
                ; using mantissa buffer (8 chars = 2 sets of 4 chars)
        ldy #4  ; set index to mant2, e.g. "14159000" = "9000"
        ;LoadAddress mantissafp
        ;jsr PrString
        ;stp
mant2:
        lda mantissafp,y
        eor #'0'
        jsr MUL10
	sta r0L			; push digit to TOS
	stz r0H
	jsr PUSH
	jsr ADD			; add it to TOS
        iny
        cpy #8          ; end of mantissa 9000:0000
        bne mant2       ; get next digit
;        jsr FPSTACK
;pause:  jmp pause
        jsr U32DIV16    ; divide by 10,000; TOS = 0000:AAAA
        ;jsr FPSTACK
;pause:  jmp pause
        ldy #0          ; process mant1
	StoreImm $0000, r0	; zero accumulator in TOS
	jsr PUSH		; clobbers r0!!!
mant1:  
        lda mantissafp,y
        eor #'0'
        jsr MUL10
	sta r0L			; push digit to TOS
	stz r0H
	jsr PUSH
	jsr ADD			; add it to TOS
        iny
        cpy #4          ; end of mant1
        bne mant1       ; get next digit
                        ; TOS = BBBB:AAAA
        ldx FPSP
        lda SIH-1,x     ; merge TOS.int with TOS-1.man
        sta SIH-2,x
        lda SIL-1,x
        sta SIL-2,x
        jsr DROP        ; drop the integer part (TOS) since TOS-1 has it
;        jsr FPSTACK
;pause:  jmp pause
        jsr U32DIV16    ; divide by 10,000; TOS = XXXX:YYYY
                        ; U32DIV16 merges YYYY to integer part 
	; TOS   = fp as signed integer:mantissa
;        jsr FPSTACK
;pause:  jmp pause
xatofpend:
	ply
	plx
	pla
        rts
        ;     
        ; string parser
	;
xgetnxtfp:
        iny                     ; bump the buffer pointer
xgettxtfp:
        lda (r11),y             ; grab a char from text buffer
        cmp #' '                ;
        beq xgetnxtfp           ; skip over any space char(s)
        eor #'0'                ;
        cmp #10                 ; ASCII decimal digit?
        bcc xgottxtfp           ;   yes: CC, convert to binary
        eor #'0'                ;   no : CS, return orig. ASCII
xgottxtfp:
        rts                     ;
mantissafp:
        .asciiz  "00000000"     ; 8 decimal points, (mant1:mant2)
;
;
;

.include "./includes/io.a65"
.include "./includes/math.a65"
.include "./includes/mathfp.a65"